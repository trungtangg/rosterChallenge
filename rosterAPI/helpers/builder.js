/**
 * Response handlers and functions to help format objects
 */
const Helper = require('./helper');

/**
 * Sends an error response based on the type of error
 * @param {Response} res response sent by service
 * @param {Error} error error generated by the service
 */
const sendErrorResponse = (res, error) => {
  Helper.logStamp(error.stack, true);
  let returnObj = new Object();
  returnObj.time = Helper.timeStamp();
  switch (error.name) {
    case 'MongoError':
      returnObj.message = error.errmsg;
      res.status(400);
      break;
    case 'CustomError':
    case 'CastError':
    case 'ValidationError':
      returnObj.message = error.message;
      res.status(400);
      break;
    case 'ReferenceError':
    default: /* Default response handler */
      returnObj.message = error.message;
      res.status(500);
      break;
  }
  res.send(returnObj);
};

/**
 * Sends the response based on the request type
 * @param {string} reqMethod type of request
 * @param {any} limiters set of fields to paginate the result
 * @param {Response} res response sent by service
 * @param {any} result the result of the transaction on the db
 * @param {number} total count of total documents
 */
const sendSuccessResponse = (reqMethod, res, result, limiters, total) => {
  let returnObj = new Object();
  switch (reqMethod) {
    case 'GET':
      if (Array.isArray(result)) {
        returnObj = formatArrayResponse(result, total, limiters);
      } else {
        returnObj = result;
      }
      res.status(200).send(returnObj);
      break;
    case 'PUT':
      res.status(200).send({ message: 'REPLACED' });
      break;
    case 'POST':
      res.status(201).send({ message: 'CREATED' });
      break;
    case 'PATCH':
      res.status(200).send({ fields: result, message: 'UPDATED' });
      break;
    case 'DELETE':
      res.status(204).send();
      break;
  }
};

/**
 * Formats fields required to paginate any service request for many documents
 * @param {any} query set of fields passed from the client
 * @param {number} defaultLimit the limit of records to display; default of 100
 */
const formatManyRequest = (query, defaultLimit = 100) => {
  let returnObj = new Object();
  if (query.sort) {
    returnObj.sort = query.sort[0] === '-' ? { [query.sort.substr(1)]: -1, _id: 1 } : { [query.sort]: 1, _id: 1 };
  } else {
    returnObj.sort = new Object();
  }
  returnObj.limit = query.limit ? parseInt(query.limit) : defaultLimit;
  returnObj.page = query.page ? parseInt(query.page) : 1;
  returnObj.skip = query.page ? returnObj.limit * parseInt(query.page - 1) : 0;
  return returnObj;
};

/**
 * Iterates through the array of filter properties and combines them into one
 * @param {any[]} fields list of fields to be filtered by the query
 */
const formatFilter = (fields) => {
  let returnObj = new Object();
  if (fields) {
    let filters = JSON.parse(decodeURIComponent(fields));
    filters.forEach((filter) => {
      switch (filter.type) {
        case 'regex':
          returnObj[filter.key] = new RegExp(filter.value, 'i');
          break;
        default:
          returnObj[filter.key] = filter.value;
          break;
      }
    });
  }
  return returnObj;
};

/************ SUPPORT FUNCTIONS ************/

/**
 * Format the pagination information to send to the client
 * @param {any[]} result list of records requested by the client
 * @param {number} total total amount of records returned by the service
 * @param {any} limiters set of fields to paginate the result
 */
const formatArrayResponse = (result, total, limiters) => {
  return {
    list: result,
    footer: {
      page: limiters.page,
      totalPages: Math.ceil(total / limiters.limit),
      listLimit: limiters.limit,
      total: total,
    },
  };
};

/**
 * Formats the range for queries between a low and high field
 * @param {any} filter object to be used as filter in the query
 * @param {any} range range desired by the client
 */
const formatRange = (filter, range) => {
  let fields = JSON.parse(decodeURIComponent(range));
  let lowLimit = new Object();
  let highLimit = new Object();
  switch (fields.type) {
    case 'number':
      lowLimit[fields.key] = { '$gte': Number(fields.low) }
      highLimit[fields.key] = { '$lte': Number(fields.high) }
      break;
    case 'date': 
      /* Designed to be simple to add range Dates if needed */
      break;
  }
  filter['$and'] = [];
  filter['$and'].push(lowLimit);
  filter['$and'].push(highLimit);
};

module.exports = {
  sendErrorResponse,
  sendSuccessResponse,
  formatManyRequest,
  formatFilter,
  formatRange,
};
